<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MPC Policy Rate Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root {
      --bg: #f5f7fb;
      --fg: #0b1222;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --card: #ffffff;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    header {
      max-width: 1100px;
      margin: 24px auto 8px;
      padding: 0 16px;
    }
    h1 {
      margin: 0 0 4px;
      font-size: 26px;
      font-weight: 800;
    }
    .lede {
      margin: 0 0 16px;
      color: var(--muted);
      font-size: 14px;
    }
    main {
      max-width: 1100px;
      margin: 0 auto 32px;
      padding: 0 16px 32px;
    }
    .card {
      background: var(--card);
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 16px;
      box-shadow: 0 1px 2px rgba(15,23,42,0.04);
      margin-bottom: 16px;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }
    .scenario-row {
      display: grid;
      grid-template-columns: 2fr 1fr 2fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .scenario-row input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 13px;
    }
    .scenario-row input[type="file"] {
      font-size: 12px;
    }
    .scenario-row label {
      font-size: 12px;
      color: var(--muted);
    }
    .scenario-row button {
      border: none;
      background: transparent;
      color: #ef4444;
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-ghost {
      background: transparent;
      color: var(--fg);
      border-color: var(--border);
    }
    .btn + .btn {
      margin-left: 8px;
    }
    .step-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
    }
    #dashboard-step {
      display: none;
    }
    .charts-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }
    .chart-box {
      flex: 0 0 calc(50% - 8px); /* always half width on desktop */
      min-width: 0;
      height: 260px;
    }
    @media (max-width: 959px) {
      .chart-box {
        flex: 0 0 100%;          /* full width on smaller screens */
      }
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
    }
    th {
      background: #f9fafb;
      font-weight: 600;
      text-align: center;
    }
    td {
      text-align: center;
    }
    .table-option {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }
    .table-option input {
      margin: 0;
    }
    .chart-toggle,
    .table-var-checkbox,
    .table-frequency-radio {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    }
    .chart-pill-label,
    .table-var-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0;
      position: relative;
    }
    .chart-toggle + span,
    .table-var-checkbox + span,
    .table-frequency-radio + span {
    padding: 3px 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #ffffff;
    color: var(--muted);
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    white-space: nowrap;
    }
    .chart-toggle:checked + span,
    .table-var-checkbox:checked + span,
    .table-frequency-radio:checked + span {
    border-color: var(--accent);
    background: rgba(37,99,235,0.07);
    color: var(--accent);
    }
    .table-vars {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    caption {
      caption-side: top;
      text-align: left;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--muted);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      background: #e0f2fe;
      color: #0369a1;
      font-size: 11px;
      font-weight: 500;
    }
    .range-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .range-input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 12px;
    }
    .range-sep {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .range-hint {
      font-size: 11px;
      color: var(--muted);
    }
    .site-footer {
      max-width: 1100px;
      margin: 0 auto 24px;
      padding: 8px 16px 0;
      font-size: 11px;
      color: var(--muted);
      text-align: right;
    }
    .download-wrapper{position:relative;display:inline-flex;align-items:center;}
    .download-menu{position:absolute;right:0;top:calc(100% + 6px);background:var(--card);border-radius:8px;border:1px solid var(--border);box-shadow:0 10px 25px rgba(15,23,42,0.12);padding:8px;min-width:220px;opacity:0;transform:translateY(-4px);pointer-events:none;transition:opacity .16s ease,transform .16s ease;z-index:20;}
    .download-menu.open{opacity:1;transform:translateY(0);pointer-events:auto;}
    .download-menu button{width:100%;text-align:left;border:none;background:transparent;padding:6px 8px;border-radius:6px;font-size:12px;cursor:pointer;}
    .download-menu button:hover{background:#eff6ff;}
  </style>
</head>
<body>

<header>
  <h1>MPC Policy Rate Projection Dashboard</h1>
  <p class="lede">
    Upload MPC projections (chartpackcsv), then compare output gaps and policy rate projections across scenarios.
  </p>
</header>

<main>
  <!-- Step 1: config and upload -->
  <section id="config-step" class="card">
    <h2>1. Upload projection files</h2>
    <div id="scenario-list"></div>
    <button id="add-scenario" class="btn btn-ghost">+ Add scenario</button>

    <div class="step-actions">
      <!-- Button moved to range-config; this area stays empty to keep spacing if needed -->
    </div>
  </section>

  <!-- Step 1.5: range configuration -->
  <section id="range-config" class="card">
    <h2>2. Set plot and table ranges</h2>
    <p style="font-size:13px;color:var(--muted);margin-bottom:10px;">
      Define the common time ranges used for all charts and tables. Leave fields blank to use defaults.
    </p>

    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;align-items:flex-start;max-width:100%;">
      <!-- Plot range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Plot range (all charts)
        </label>
        <div class="range-row">
          <select id="plot-min" class="range-input"></select>
          <span class="range-sep">to</span>
          <select id="plot-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–2030Q4</div>
      </div>

      <!-- Actual data range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Actual data range (shaded)
        </label>
        <div class="range-row">
          <select id="actual-min" class="range-input" disabled></select>
          <span class="range-sep">to</span>
          <select id="actual-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–current quarter</div>
      </div>

      <!-- Table range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Table range
        </label>
        <div class="range-row">
          <select id="table-min" class="range-input"></select>
          <span class="range-sep">to</span>
          <select id="table-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–2030Q4</div>
      </div>
    </div>
    <div class="step-actions">
      <button id="build-dashboard" class="btn btn-primary">Build dashboard</button>
    </div>
  </section>

  <!-- Step 2: dashboard -->
  <section id="dashboard-step">
    <div class="card" style="margin-bottom:20px;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;">
        <h2 style="margin:0;">Interactive dashboard</h2>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="pill" id="scenario-count-label"></span>
          <div id="download-wrapper" class="download-wrapper">
            <button id="download-toggle" class="btn btn-primary">Download dashboard (.html)</button>
            <div id="download-menu" class="download-menu">
              <button type="button" data-export-mode="interactive">Interactive version (with controls)</button>
              <button type="button" data-export-mode="fixed">Fixed snapshot (no controls)</button>
            </div>
          </div>
          <button id="back-to-config" class="btn btn-ghost">Back to file selection</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div id="scenario-legend" style="margin-bottom:8px;font-size:11px;color:var(--muted);"></div>
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px;">
        <h3 style="margin:0;font-size:14px;">Charts</h3>
        <div id="chart-toggle-row" style="display:flex;flex-wrap:wrap;gap:8px;font-size:11px;color:var(--muted);">
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-output-gap" checked>
            <span>Output Gap</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-output-levels" checked>
            <span>Output &amp; Potential</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-headline-yoy" checked>
            <span>Headline YoY</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-core-yoy">
            <span>Core YoY</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-policy" checked>
            <span>Policy Rate</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-policy-step">
            <span>Policy Rate (step)</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-potential-growth">
            <span>Potential Growth</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-core-qoq">
            <span>Core QoQ</span>
          </label>
          <label class="chart-pill-label" style="display:inline-flex;align-items:center;gap:4px;">
            <input type="checkbox" class="chart-toggle" data-chart-id="chart-headline-qoq">
            <span>Headline QoQ</span>
          </label>
        </div>
      </div>
      <div class="charts-grid">
        <div class="chart-box" id="chart-output-gap"></div>
        <div class="chart-box" id="chart-output-levels"></div>
        <div class="chart-box" id="chart-headline-yoy"></div>
        <div class="chart-box" id="chart-core-yoy"></div>
        <div class="chart-box" id="chart-policy"></div>
        <div class="chart-box" id="chart-policy-step"></div>
        <div class="chart-box" id="chart-potential-growth"></div>
        <div class="chart-box" id="chart-core-qoq"></div>
        <div class="chart-box" id="chart-headline-qoq"></div>
      </div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px;gap:12px;flex-wrap:wrap;">
        <h3 style="margin:0;font-size:14px;">Summary table</h3>
        <div id="summary-var-controls" style="display:flex;flex-direction:column;gap:6px;flex:1;min-width:0;">
          <!-- View (Q vs Y) -->
          <div style="display:inline-flex;align-items:center;gap:8px;flex-wrap:wrap;">
            <span style="font-size:11px;color:var(--muted);">View:</span>
            <label class="table-var-toggle">
              <input type="radio" class="table-frequency-radio" name="table-frequency" value="quarterly" checked>
              <span>Quarterly</span>
            </label>
            <label class="table-var-toggle">
              <input type="radio" class="table-frequency-radio" name="table-frequency" value="yearly">
              <span>Yearly</span>
            </label>
          </div>
          <!-- Variables -->
          <div>
            <span style="display:inline-block;margin-bottom:2px;font-size:11px;color:var(--muted);">Variables:</span>
            <div class="table-vars">
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="ygap" checked>
                <span>Output Gap</span>
              </label>
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="policy" checked>
                <span>Policy Rate</span>
              </label>
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="policyStep" checked>
                <span>Policy Rate (step)</span>
              </label>
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="headlineYoy">
                <span>Headline YoY</span>
              </label>
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="coreYoy">
                <span>Core YoY</span>
              </label>
              <label class="table-var-toggle">
                <input type="checkbox" class="table-var-checkbox" data-var-id="gdp">
                <span>GDP Growth YoY</span>
              </label>
            </div>
          </div>
        </div>
        <!-- Color-code toggle separated on the right -->
        <label id="summary-color-toggle" class="table-option" style="align-self:flex-start;">
          <input type="checkbox" id="color-code-headers">
          <span>Color-code scenarios</span>
        </label>
      </div>
      <div id="summary-legend" style="margin-bottom:8px;font-size:11px;color:var(--muted);display:none;"></div>
      <div id="summary-tables"></div>
    </div>
  </section>
</main>

<script>
  // Global state
  const maxScenarios = 6;
  const scenarios = []; // {id, name, color, file, data}

  // Default ranges
  const defaultPlotMin = "2019Q4";
  const defaultPlotMax = "2030Q4";
  const defaultTableMin = "2019Q4";
  const defaultTableMax = "2030Q4";
  const defaultActualMin = "2019Q4";
  let availablePeriods = [];
  let currentScenarios = [];
  let colorCodeTableHeaders = false;
    let summaryFrequency = "quarterly"; // "quarterly" or "yearly"

  const tableVarConfig = {
    ygap: {
      id: "ygap",
      label: "Output Gap (%)",
      accessor: r => Number(r.ygap)
    },
    policy: {
      id: "policy",
      label: "Policy Rate (%)",
      accessor: r => Number(r.i)
    },
    policyStep: {
      id: "policyStep",
      label: "Policy Rate (%, step)",
      accessor: r => {
        const v = Number(r.i);
        if (typeof v === "number" && !isNaN(v)) {
          return Math.round(v / 0.25) * 0.25;
        }
        return NaN;
      }
    },
    headlineYoy: {
      id: "headlineYoy",
      label: "Headline Inflation (%YoY)",
      accessor: r => Number(r.picpi4)
    },
    coreYoy: {
      id: "coreYoy",
      label: "Core Inflation (%YoY)",
      accessor: r => Number(r.pi4)
    },
    gdp: {
      id: "gdp",
      label: "GDP Growth (%YoY)",
      accessor: r => Number(r.y_growth)
    }
  };


  function augmentScenarioDataWithGrowth(rows) {
    if (!Array.isArray(rows)) return rows;

    const validRows = rows.filter(r =>
      r.period != null &&
      r.period !== "" &&
      parsePeriodToIndex(r.period) != null
    );

    if (!validRows.length) return rows;

    // Sort by time so we can compute 4-quarter rolling stats
    const sorted = [...validRows].sort((a, b) => {
      return parsePeriodToIndex(a.period) - parsePeriodToIndex(b.period);
    });

    const indexMap = {};
    sorted.forEach(r => {
      const idx = parsePeriodToIndex(r.period);
      if (idx != null) indexMap[idx] = r;
    });

    function rollingMean(key, i) {
      const window = 4;
      if (i < window - 1) return null;
      let sum = 0;
      let count = 0;
      for (let k = i - window + 1; k <= i; k++) {
        const v = sorted[k][key];
        if (typeof v !== "number" || isNaN(v)) return null;
        sum += v;
        count++;
      }
      if (count < window) return null;
      return sum / count;
    }

    // First pass: compute quarterly y_growth, annual_GDP, and 4Q rolling means
    for (let i = 0; i < sorted.length; i++) {
      const r = sorted[i];
      const idx = parsePeriodToIndex(r.period);
      const prev = idx != null ? indexMap[idx - 4] : null;

      const yNow  = typeof r.y === "number" ? r.y : null;
      const yPrev = prev && typeof prev.y === "number" ? prev.y : null;

      // y_growth = (y / lag(y, 4) - 1) * 100
      if (yNow != null && yPrev != null && yPrev !== 0) {
        r.y_growth = (yNow / yPrev - 1) * 100;
      } else {
        r.y_growth = r.y_growth ?? null;
      }

      const p = String(r.period).trim();
      if (/Q4$/.test(p) && typeof r.dyA_nonsa === "number") {
        r.annual_GDP = r.dyA_nonsa;
      } else {
        r.annual_GDP = r.annual_GDP ?? null;
      }

      // 4-quarter averages for yearly view
      const avgGap = rollingMean("ygap", i);
      if (avgGap != null) {
        r.avg_ygap = avgGap;
      }

      const cpiMA = rollingMean("cpi_nonsa", i);
      if (cpiMA != null) {
        r.cpi_ma4 = cpiMA;
      }

      const coreMA = rollingMean("core_nonsa", i);
      if (coreMA != null) {
        r.core_ma4 = coreMA;
      }
    }

    // Second pass: yearly HL_inf and CORE_inf from 4Q moving averages
    for (let i = 0; i < sorted.length; i++) {
      const r = sorted[i];
      const idx = parsePeriodToIndex(r.period);
      const prev = idx != null ? indexMap[idx - 4] : null;

      if (typeof r.cpi_ma4 === "number" && prev && typeof prev.cpi_ma4 === "number" && prev.cpi_ma4 !== 0) {
        r.HL_inf = (r.cpi_ma4 / prev.cpi_ma4 - 1) * 100;
      } else {
        r.HL_inf = r.HL_inf ?? null;
      }

      if (typeof r.core_ma4 === "number" && prev && typeof prev.core_ma4 === "number" && prev.core_ma4 !== 0) {
        r.CORE_inf = (r.core_ma4 / prev.core_ma4 - 1) * 100;
      } else {
        r.CORE_inf = r.CORE_inf ?? null;
      }
    }

    return rows;
  }


  function getCurrentQuarterLabel() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth(); // 0-based
    const q = Math.floor(month / 3) + 1;
    return year + "Q" + q;
  }
  const defaultActualMax = getCurrentQuarterLabel();

  const scenarioListEl   = document.getElementById("scenario-list");
  const addScenarioBtn   = document.getElementById("add-scenario");
  const buildDashboardBtn = document.getElementById("build-dashboard");
  const configStepEl     = document.getElementById("config-step");
  const dashboardStepEl  = document.getElementById("dashboard-step");
  const backToConfigBtn  = document.getElementById("back-to-config");
  const scenarioCountLbl = document.getElementById("scenario-count-label");
  const downloadWrapperEl      = document.getElementById("download-wrapper");
  const downloadToggleBtn      = document.getElementById("download-toggle");
  const downloadMenuEl         = document.getElementById("download-menu");
  const summaryTablesEl  = document.getElementById("summary-tables");
  const rangeConfigEl    = document.getElementById("range-config");
  const scenarioLegendEl = document.getElementById("scenario-legend");
  const summaryLegendEl  = document.getElementById("summary-legend");
  const rangeHeadingEl   = rangeConfigEl ? rangeConfigEl.querySelector("h2") : null;
  const rangeActionsEl   = rangeConfigEl ? rangeConfigEl.querySelector(".step-actions") : null;
  const colorCodeHeadersCheckbox = document.getElementById("color-code-headers");
  if (colorCodeHeadersCheckbox) {
    colorCodeHeadersCheckbox.addEventListener("change", () => {
      colorCodeTableHeaders = !!colorCodeHeadersCheckbox.checked;
      if (!colorCodeTableHeaders && summaryLegendEl) {
        summaryLegendEl.style.display = "none";
        summaryLegendEl.innerHTML = "";
      }
      reRenderIfReady();
    });
  }
  function renderSummaryLegend(scenarios) {
    if (!summaryLegendEl) return;
    if (!colorCodeTableHeaders || !scenarios || !scenarios.length) {
      summaryLegendEl.style.display = "none";
      summaryLegendEl.innerHTML = "";
      return;
    }
    const items = scenarios.map(s => {
      const color = s.color || "#000000";
      const name = s.name || "Scenario";
      return `
        <span style="display:inline-flex;align-items:center;margin-right:8px;margin-bottom:4px;">
          <span style="width:10px;height:10px;border-radius:999px;background:${color};display:inline-block;margin-right:4px;"></span>
          <span>${name}</span>
        </span>
      `;
    });
    summaryLegendEl.innerHTML = items.join("");
    summaryLegendEl.style.display = "block";
  }

  const plotMinInput   = document.getElementById("plot-min");
  const plotMaxInput   = document.getElementById("plot-max");
  const actualMinInput = document.getElementById("actual-min");
  const actualMaxInput = document.getElementById("actual-max");
  const tableMinInput  = document.getElementById("table-min");
  const tableMaxInput  = document.getElementById("table-max");


  function getRangeConfig() {
    return {
      plotMin: (plotMinInput && plotMinInput.value) || defaultPlotMin,
      plotMax: (plotMaxInput && plotMaxInput.value) || defaultPlotMax,
      actualMin: (plotMinInput && plotMinInput.value) || defaultPlotMin,
      actualMax: (actualMaxInput && actualMaxInput.value) || defaultActualMax,
      tableMin: (tableMinInput && tableMinInput.value) || defaultTableMin,
      tableMax: (tableMaxInput && tableMaxInput.value) || defaultTableMax
    };
  }

  function getAllPeriodsFromScenarios(scens) {
    const set = new Set();
    scens.forEach(s => {
      (s.data || []).forEach(r => {
        if (r.period != null && r.period !== "") {
          const p = String(r.period).trim();
          if (parsePeriodToIndex(p) != null) {
            set.add(p);
          }
        }
      });
    });
    const arr = Array.from(set);
    arr.sort((a, b) => parsePeriodToIndex(a) - parsePeriodToIndex(b));
    return arr;
  }

  function populateSelectFromPeriods(selectEl, defaultVal, isMax) {
    if (!selectEl || !availablePeriods.length) return;
    selectEl.innerHTML = "";
    availablePeriods.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      selectEl.appendChild(opt);
    });

    const first = availablePeriods[0];
    const last = availablePeriods[availablePeriods.length - 1];
    const firstIdx = parsePeriodToIndex(first);
    const lastIdx = parsePeriodToIndex(last);

    let chosen = defaultVal;
    const chosenIdx = chosen && parsePeriodToIndex(chosen);

    if (!chosenIdx) {
      chosen = isMax ? last : first;
    } else {
      if (chosenIdx < firstIdx) chosen = first;
      if (chosenIdx > lastIdx) chosen = last;
    }

    selectEl.value = chosen;
  }

  function populateRangeSelects() {
    if (!availablePeriods.length) return;
    populateSelectFromPeriods(plotMinInput, defaultPlotMin, false);
    populateSelectFromPeriods(plotMaxInput, defaultPlotMax, true);
    populateSelectFromPeriods(actualMinInput, defaultActualMin, false);
    populateSelectFromPeriods(actualMaxInput, defaultActualMax, true);
    populateSelectFromPeriods(tableMinInput, defaultTableMin, false);
    populateSelectFromPeriods(tableMaxInput, defaultTableMax, true);

    // Keep actual-min aligned with plot-min and non-editable
    if (plotMinInput && actualMinInput) {
      actualMinInput.value = plotMinInput.value;
      actualMinInput.disabled = true;
    }
  }

  function refreshAvailablePeriodsAndSelects() {
    const scensWithData = scenarios.filter(s => Array.isArray(s.data) && s.data.length > 0);
    if (!scensWithData.length) {
      availablePeriods = [];
      return;
    }
    availablePeriods = getAllPeriodsFromScenarios(scensWithData);
    populateRangeSelects();
  }

  // Helpers
  function createScenarioRow(id, scenario) {
    const row = document.createElement("div");
    row.className = "scenario-row";
    row.dataset.id = id;

    row.innerHTML = `
      <div>
        <label>Scenario name</label>
        <input type="text" placeholder="e.g. MPC Dec-25 (Day 1)" class="scenario-name">
      </div>
      <div>
        <label>Line color</label>
        <input type="color" class="scenario-color" value="${scenario.color}">
      </div>
      <div>
        <label>CSV file</label>
        <input type="file" accept=".csv" class="scenario-file">
      </div>
      <button type="button" class="remove-scenario" title="Remove scenario">&times;</button>
    `;

    // Wire remove
    row.querySelector(".remove-scenario").addEventListener("click", () => {
      const idx = scenarios.findIndex(s => s.id === id);
      if (idx >= 0) scenarios.splice(idx, 1);
      row.remove();
      refreshAvailablePeriodsAndSelects();
    });

    // Wire inputs to state
    row.querySelector(".scenario-name").addEventListener("input", e => {
      const s = scenarios.find(s => s.id === id);
      if (s) s.name = e.target.value;
    });
    row.querySelector(".scenario-color").addEventListener("input", e => {
      const s = scenarios.find(s => s.id === id);
      if (s) s.color = e.target.value;
    });
    row.querySelector(".scenario-file").addEventListener("change", e => {
      const s = scenarios.find(s => s.id === id);
      const file = e.target.files[0] || null;
      if (s) s.file = file;

      if (file) {
        // Extract name
        let fname = file.name.replace(/\.[^/.]+$/, ""); // remove extension

        // Convert "chartpackcsv_Dec25_Internal Briefing" into "MPC Dec-25 (Internal Briefing)"
        // Step 1: extract month+year (e.g. Dec25)
        const match = fname.match(/_(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{2})/i);
        let scenarioLabel = "";

        if (match) {
          const m = match[1];
          const y = match[2];
          scenarioLabel = `MPC ${m}-${y}`;
        } else {
          scenarioLabel = "MPC Scenario";
        }

        // Step 2: extract descriptor after month-year
        const parts = fname.split(match ? match[0] : "");
        if (parts.length > 1) {
          let desc = parts[1].replace(/[_-]+/g, " ").trim();
          if (desc) scenarioLabel += ` (${desc})`;
        }

        // Update scenario state + input field
        s.name = scenarioLabel;
        row.querySelector(".scenario-name").value = scenarioLabel;

        // Parse this file immediately to populate data and refresh ranges
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: results => {
            const rows = results.data.filter(r => r.period != null && r.period !== "");
            augmentScenarioDataWithGrowth(rows);
            s.data = rows;
            refreshAvailablePeriodsAndSelects();
          },
          error: err => {
            console.error(err);
            alert("There was a problem reading " + file.name + ". Please check the format.");
          }
        });
      }
    });

    return row;
  }

  function addScenario() {
    if (scenarios.length >= maxScenarios) {
      alert(`You can upload at most ${maxScenarios} scenarios for now.`);
      return;
    }
    const id = Date.now() + "_" + Math.random().toString(16).slice(2);
    const defaultColors = ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b"];
    const scenario = {
      id,
      name: "",
      color: defaultColors[scenarios.length] || "#000000",
      file: null,
      data: null
    };
    scenarios.push(scenario);
    const row = createScenarioRow(id, scenario);
    scenarioListEl.appendChild(row);
  }

  // Initialize with 2 rows by default
  addScenario();
  addScenario();

  addScenarioBtn.addEventListener("click", addScenario);

  // Parse one scenario CSV into scenario.data
  function parseScenario(scenario) {
    return new Promise((resolve, reject) => {
      if (!scenario.file) {
        return reject(new Error("Missing file for scenario " + (scenario.name || "")));
      }
      Papa.parse(scenario.file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: results => {
          const rows = results.data.filter(r => r.period != null && r.period !== "");
          augmentScenarioDataWithGrowth(rows);
          scenario.data = rows;
          resolve(scenario);
        },
        error: err => reject(err)
      });
    });
  }

  function validateScenarios() {
    const valid = scenarios.filter(s => s.file);
    if (valid.length === 0) {
      alert("Please upload at least one CSV file.");
      return null;
    }
    // Fill default names
    valid.forEach((s, idx) => {
      if (!s.name || !s.name.trim()) {
        s.name = "Scenario " + (idx + 1);
      }
    });
    return valid;
  }

  // Main build dashboard action
  buildDashboardBtn.addEventListener("click", () => {
    const validScenarios = scenarios.filter(s => Array.isArray(s.data) && s.data.length > 0);
    if (!validScenarios.length) {
      alert("Please upload at least one valid CSV file before building the dashboard.");
      return;
    }

    // Ensure ranges are populated if not done yet
    if (!availablePeriods.length) {
      availablePeriods = getAllPeriodsFromScenarios(validScenarios);
      populateRangeSelects();
    }

    currentScenarios = validScenarios;

    // Hide upload card, keep range card visible (as part of dashboard), show dashboard
    configStepEl.style.display = "none";
    dashboardStepEl.style.display = "block";
    if (rangeConfigEl) {
      rangeConfigEl.style.display = "block";
    }
    // On the dashboard page: no "2." and no Build button
    if (rangeHeadingEl) {
      rangeHeadingEl.textContent = "Set plot and table ranges";
    }
    if (rangeActionsEl) {
      rangeActionsEl.style.display = "none";
    }

    scenarioCountLbl.textContent = `${validScenarios.length} scenario${validScenarios.length > 1 ? "s" : ""} loaded`;
    renderDashboard(currentScenarios);
  });

  backToConfigBtn.addEventListener("click", () => {
    dashboardStepEl.style.display = "none";
    configStepEl.style.display = "block";
    if (rangeConfigEl) {
      rangeConfigEl.style.display = "block";
    }
    // Back on the first page: show "2." and the Build button again
    if (rangeHeadingEl) {
      rangeHeadingEl.textContent = "2. Set plot and table ranges";
    }
    if (rangeActionsEl) {
      rangeActionsEl.style.display = "flex";
    }
  });
  if (downloadToggleBtn && downloadMenuEl) {
    downloadToggleBtn.addEventListener("click", () => {
      downloadMenuEl.classList.toggle("open");
    });

    downloadMenuEl.querySelectorAll("button[data-export-mode]").forEach(btn => {
      btn.addEventListener("click", () => {
        const mode = btn.getAttribute("data-export-mode");
        const exportFixed = (mode === "fixed");
        downloadMenuEl.classList.remove("open");
        downloadStandaloneDashboard(exportFixed);
      });
    });

    document.addEventListener("click", evt => {
      if (!downloadWrapperEl) return;
      if (!downloadWrapperEl.contains(evt.target)) {
        downloadMenuEl.classList.remove("open");
      }
    });
  }

  function downloadStandaloneDashboard(exportFixed) {
    if (!currentScenarios || !currentScenarios.length) {
      alert("Please build the dashboard before downloading.");
      return;
    }

    // Capture current UI state (chart visibility, table variables, color-coding)
    const chartSelections = {};
    document.querySelectorAll(".chart-toggle").forEach(t => {
      const id = t.getAttribute("data-chart-id");
      if (id) {
        chartSelections[id] = !!t.checked;
      }
    });

    const tableVarSelections = {};
    document.querySelectorAll(".table-var-checkbox").forEach(cb => {
      const id = cb.getAttribute("data-var-id");
      if (id) {
        tableVarSelections[id] = !!cb.checked;
      }
    });

    const colorCodeCheckbox = document.getElementById("color-code-headers");
    const colorCodeHeadersState = !!(colorCodeCheckbox && colorCodeCheckbox.checked);

    const uiState = {
      charts: chartSelections,
      tableVars: tableVarSelections,
      colorCodeHeaders: colorCodeHeadersState
    };

    // Prepare data to embed
    const exportScenarios = currentScenarios.map(s => ({
      name: s.name,
      color: s.color,
      data: s.data
    }));
    const ranges = getRangeConfig();

    const exportScenariosJson = JSON.stringify(exportScenarios).replace(/<\/script/gi, "<\\/script");
    const exportRangesJson = JSON.stringify(ranges).replace(/<\/script/gi, "<\\/script");
    const exportSummaryFreqJson = JSON.stringify(summaryFrequency);
    const exportUIStateJson = JSON.stringify(uiState).replace(/<\/script/gi, "<\\/script");
    const exportFixedJson = JSON.stringify(!!exportFixed);

    const injectionScript = `
<script>
(function(){
  window.__EXPORTED_SCENARIOS = ${exportScenariosJson};
  window.__EXPORTED_RANGES = ${exportRangesJson};
  window.__EXPORTED_SUMMARY_FREQUENCY = ${exportSummaryFreqJson};
  window.__EXPORTED_UI_STATE = ${exportUIStateJson};
  window.__EXPORTED_FIXED = ${exportFixedJson};
  document.addEventListener("DOMContentLoaded", function(){
    if (!window.__EXPORTED_SCENARIOS || !window.__EXPORTED_SCENARIOS.length) return;
    currentScenarios = window.__EXPORTED_SCENARIOS;
    availablePeriods = getAllPeriodsFromScenarios(currentScenarios);
    populateRangeSelects();
    if (typeof window.__EXPORTED_RANGES === "object" && window.__EXPORTED_RANGES) {
      if (plotMinInput && window.__EXPORTED_RANGES.plotMin) plotMinInput.value = window.__EXPORTED_RANGES.plotMin;
      if (plotMaxInput && window.__EXPORTED_RANGES.plotMax) plotMaxInput.value = window.__EXPORTED_RANGES.plotMax;
      if (actualMaxInput && window.__EXPORTED_RANGES.actualMax) actualMaxInput.value = window.__EXPORTED_RANGES.actualMax;
      if (tableMinInput && window.__EXPORTED_RANGES.tableMin) tableMinInput.value = window.__EXPORTED_RANGES.tableMin;
      if (tableMaxInput && window.__EXPORTED_RANGES.tableMax) tableMaxInput.value = window.__EXPORTED_RANGES.tableMax;
      if (actualMinInput && plotMinInput) {
        actualMinInput.value = plotMinInput.value;
        actualMinInput.disabled = true;
      }
    }

    if (typeof window.__EXPORTED_UI_STATE === "object" && window.__EXPORTED_UI_STATE) {
      var ui = window.__EXPORTED_UI_STATE;
      var chartState = ui.charts || {};
      document.querySelectorAll(".chart-toggle").forEach(function(t) {
        var id = t.getAttribute("data-chart-id");
        if (id && Object.prototype.hasOwnProperty.call(chartState, id)) {
          t.checked = !!chartState[id];
        }
      });

      var varState = ui.tableVars || {};
      document.querySelectorAll(".table-var-checkbox").forEach(function(cb) {
        var id = cb.getAttribute("data-var-id");
        if (id && Object.prototype.hasOwnProperty.call(varState, id)) {
          cb.checked = !!varState[id];
        }
      });

      if (typeof ui.colorCodeHeaders === "boolean") {
        var cc = document.getElementById("color-code-headers");
        colorCodeTableHeaders = ui.colorCodeHeaders;
        if (cc) cc.checked = colorCodeTableHeaders;
      }
    }

    if (typeof window.__EXPORTED_SUMMARY_FREQUENCY === "string") {
      summaryFrequency = window.__EXPORTED_SUMMARY_FREQUENCY;
      var radios = document.querySelectorAll(".table-frequency-radio");
      radios.forEach(function(r){
        r.checked = (r.value === summaryFrequency);
      });
    }
    if (configStepEl) configStepEl.style.display = "none";
    if (backToConfigBtn) backToConfigBtn.style.display = "none";
    if (rangeConfigEl) rangeConfigEl.style.display = "block";
    if (rangeHeadingEl) rangeHeadingEl.textContent = "Set plot and table ranges";
    if (rangeActionsEl) rangeActionsEl.style.display = "none";
    if (dashboardStepEl) dashboardStepEl.style.display = "block";
    if (scenarioCountLbl) {
      var n = currentScenarios.length;
      scenarioCountLbl.textContent = n + " scenario" + (n > 1 ? "s" : "") + " loaded";
    }

    var downloadWrap = document.getElementById("download-wrapper");
    if (downloadWrap) downloadWrap.style.display = "none";

    var ledeEl = document.querySelector(".lede");
    if (ledeEl) {
      ledeEl.style.display = "none";
    }

    if (window.__EXPORTED_FIXED) {
      if (rangeConfigEl) {
        rangeConfigEl.style.display = "none";
      }
      var chartToggleRow = document.getElementById("chart-toggle-row");
      if (chartToggleRow) {
        chartToggleRow.style.display = "none";
      }
      var summaryVarControls = document.getElementById("summary-var-controls");
      if (summaryVarControls) {
        summaryVarControls.style.display = "none";
      }
      var summaryColorToggle = document.getElementById("summary-color-toggle");
      if (summaryColorToggle) {
        summaryColorToggle.style.display = "none";
      }
    }

    renderDashboard(currentScenarios);
    if (typeof applyChartVisibility === "function") {
      applyChartVisibility();
    }
  });
})();
<\/script>
`;

    const htmlNode = document.documentElement;
    let docHtml = htmlNode.outerHTML;
    const closingTag = '</body>';
    const idx = docHtml.lastIndexOf(closingTag);
    let finalHtml;
    if (idx !== -1) {
      finalHtml =
        '<!doctype html>\n' +
        docHtml.slice(0, idx) +
        injectionScript +
        docHtml.slice(idx);
    } else {
      finalHtml = '<!doctype html>\n' + docHtml + injectionScript;
    }

    const blob = new Blob([finalHtml], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date();
    const yyyy = ts.getFullYear();
    const mm = String(ts.getMonth() + 1).padStart(2, '0');
    const dd = String(ts.getDate()).padStart(2, '0');
    a.href = url;
    a.download = 'mpc_dashboard_' + yyyy + mm + dd + '.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  function reRenderIfReady() {
    if (dashboardStepEl.style.display !== "none" && currentScenarios && currentScenarios.length) {
      renderDashboard(currentScenarios);
    }
  }

  [plotMinInput, plotMaxInput, actualMinInput, actualMaxInput, tableMinInput, tableMaxInput].forEach(el => {
    if (!el) return;
    el.addEventListener("change", () => {
      // Keep actual-min locked to plot-min
      if (el === plotMinInput && actualMinInput) {
        actualMinInput.value = plotMinInput.value;
      }
      reRenderIfReady();
    });
  });
  // Helper to compute actual data shading (shaded region) for charts
  function buildActualDataShading(ranges) {
    const shadeMin = ranges.plotMin;
    const shadeMax = ranges.actualMax;
    const minIdx = parsePeriodToIndex(shadeMin);
    const maxIdx = parsePeriodToIndex(shadeMax);
    // If plot-min is beyond actual-max (or either is invalid), do not draw shading
    if (minIdx == null || maxIdx == null || minIdx > maxIdx) {
      return [];
    }
    return [
      {
        type: "rect",
        xref: "x",
        yref: "paper",
        x0: shadeMin,
        x1: shadeMax,
        y0: 0,
        y1: 1,
        fillcolor: "rgba(15,23,42,0.08)",
        line: { width: 0 }
      }
    ];
  }

  // Chart visibility toggles
  function applyChartVisibility() {
    const toggles = document.querySelectorAll(".chart-toggle");
    toggles.forEach(toggle => {
      const targetId = toggle.getAttribute("data-chart-id");
      const targetEl = document.getElementById(targetId);
      if (!targetEl) return;
      targetEl.style.display = toggle.checked ? "block" : "none";
    });

    // After visibility changes, force Plotly to recompute sizes
    const visibleCharts = document.querySelectorAll(".chart-box");
    visibleCharts.forEach(box => {
      if (box.style.display !== "none" && typeof Plotly !== "undefined" && Plotly.Plots && typeof Plotly.Plots.resize === "function") {
        Plotly.Plots.resize(box);
      }
    });
  }

  // Initialize visibility and listen for changes
  document.addEventListener("DOMContentLoaded", () => {
    applyChartVisibility();
    const toggles = document.querySelectorAll(".chart-toggle");
    toggles.forEach(toggle => {
      toggle.addEventListener("change", applyChartVisibility);
    });

    const tableVarCheckboxes = document.querySelectorAll(".table-var-checkbox");
    tableVarCheckboxes.forEach(cb => {
      cb.addEventListener("change", reRenderIfReady);
    });
    const freqRadios = document.querySelectorAll(".table-frequency-radio");
    freqRadios.forEach(r => {
      if (r.checked) summaryFrequency = r.value;
      r.addEventListener("change", e => {
        if (e.target.checked) {
          summaryFrequency = e.target.value;
          reRenderIfReady();
        }
      });
    });
  });

  // Helpers for period range
  function parsePeriodToIndex(p) {
    if (p == null) return null;
    const m = /^(\d{4})Q([1-4])$/.exec(String(p).trim());
    if (!m) return null;
    const year = parseInt(m[1], 10);
    const q = parseInt(m[2], 10);
    if (!year || !q) return null;
    return year * 4 + q;
  }

  function periodInRange(p, minP, maxP) {
    const idx = parsePeriodToIndex(p);
    if (idx == null) return true; // if we cannot parse, do not filter out
    const minIdx = minP ? parsePeriodToIndex(minP) : null;
    const maxIdx = maxP ? parsePeriodToIndex(maxP) : null;
    if (minIdx != null && idx < minIdx) return false;
    if (maxIdx != null && idx > maxIdx) return false;
    return true;
  }

  function parsePeriodParts(p) {
    const m = /^(\d{4})Q([1-4])$/.exec(String(p).trim());
    if (!m) return null;
    return { year: parseInt(m[1], 10), q: parseInt(m[2], 10) };
  }

  function buildXAxisLayout(ranges) {
    if (!availablePeriods.length) return {};
    const inPlot = availablePeriods.filter(p =>
      periodInRange(p, ranges.plotMin, ranges.plotMax)
    );
    if (!inPlot.length) return {};

    // Decide tick density based on how many quarters are in range
    const n = inPlot.length;
    let mode; // "all", "yearly", "biennial"
    if (n <= 12) {
      mode = "all";          // up to 3 years: show every quarter label
    } else if (n <= 40) {
      mode = "yearly";       // medium: show roughly yearly ticks
    } else {
      mode = "biennial";     // long horizon: show every 2 years
    }

    // Helper: pick one representative quarter per year (prefer Q1, else Q1 in that year, else fallback)
    const periodSet = new Set(inPlot);
    const firstParts = parsePeriodParts(inPlot[0]);
    const lastParts  = parsePeriodParts(inPlot[inPlot.length - 1]);
    if (!firstParts || !lastParts) return {};

    const tickvals = [];
    const ticktext = [];
    const stepYears = mode === "biennial" ? 2 : 1;

    for (let y = firstParts.year; y <= lastParts.year; y += stepYears) {
      let candidate = `${y}Q1`;
      if (!periodSet.has(candidate)) {
        // Try to find Q1 in this year in the plot range
        const alt = inPlot.find(p => {
          const parts = parsePeriodParts(p);
          return parts && parts.year === y && parts.q === 1;
        });
        if (!alt) {
          // Fallback: any quarter in this year in the plot range
          const fallback = inPlot.find(p => {
            const parts = parsePeriodParts(p);
            return parts && parts.year === y;
          });
          if (fallback) candidate = fallback; else continue;
        } else {
          candidate = alt;
        }
      }
      if (!periodInRange(candidate, ranges.plotMin, ranges.plotMax)) continue;
      tickvals.push(candidate);
      ticktext.push(String(y));
    }

    if (mode === "all") {
      // For short ranges, show all quarter labels
      return {
        tickmode: "array",
        tickvals: inPlot,
        ticktext: inPlot
      };
    }

    // For yearly/biennial: always use full Qx labels for tickvals, year for ticktext
    return {
      tickmode: "array",
      tickvals: tickvals,     // full Qx labels preserved
      ticktext: ticktext      // year-only text
    };
  }

  function getSeries(scenario, colName, minPeriod, maxPeriod) {
    const rows = scenario.data || [];
    const x = [];
    const y = [];
    for (const r of rows) {
      const xv = r.period;
      const yv = r[colName];
      if (
        xv != null &&
        xv !== "" &&
        typeof yv === "number" &&
        !isNaN(yv) &&
        periodInRange(xv, minPeriod, maxPeriod)
      ) {
        x.push(xv);
        y.push(yv);
      }
    }
    return { x, y };
  }

  // Render plots and tables
  function renderScenarioLegend(scenarios) {
    if (!scenarioLegendEl) return;
    if (!scenarios || !scenarios.length) {
      scenarioLegendEl.innerHTML = "";
      return;
    }
    const items = scenarios.map(s => {
      const color = s.color || "#000000";
      const name = s.name || "Scenario";
      return `
        <span style="display:inline-flex;align-items:center;margin-right:8px;margin-bottom:4px;">
          <span style="width:10px;height:10px;border-radius:999px;background:${color};display:inline-block;margin-right:4px;"></span>
          <span>${name}</span>
        </span>
      `;
    });
    scenarioLegendEl.innerHTML = items.join("");
  }

  function renderDashboard(scenarios) {
    const ranges = getRangeConfig();
    renderScenarioLegend(scenarios);
    renderOutputGapChart(scenarios, ranges);
    renderOutputLevelsChart(scenarios, ranges);
    renderHeadlineYoyChart(scenarios, ranges);
    renderCoreYoyChart(scenarios, ranges);
    renderPolicyChart(scenarios, ranges);
    renderPolicyStepChart(scenarios, ranges);
    renderPotentialGrowthChart(scenarios, ranges);
    renderCoreQoqChart(scenarios, ranges);
    renderHeadlineQoqChart(scenarios, ranges);
    renderSummaryTables(scenarios, ranges);

    // Ensure all charts fit their grid cells on initial render
    const visibleCharts = document.querySelectorAll(".chart-box");
    visibleCharts.forEach(box => {
      if (box.style.display !== "none" && typeof Plotly !== "undefined" && Plotly.Plots && typeof Plotly.Plots.resize === "function") {
        Plotly.Plots.resize(box);
      }
    });
  }

  function renderPolicyChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "i", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Policy Rate (%)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-policy", traces, layout, { responsive: true });
  }

  function renderPolicyStepChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const raw = getSeries(s, "i", ranges.plotMin, ranges.plotMax);
      const steppedY = raw.y.map(v => {
        if (typeof v === "number" && !isNaN(v)) {
          return Math.round(v / 0.25) * 0.25;
        }
        return null;
      });
      return {
        x: raw.x,
        y: steppedY,
        customdata: raw.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color, dash: "dot" },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Policy Rate (%, in 0.25 increments)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-policy-step", traces, layout, { responsive: true });
  }


  // 1) Output Gap (%): ygap
  function renderOutputGapChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "ygap", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Output Gap (%)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-output-gap", traces, layout, { responsive: true });
  }

  // 2) Output & Potential Output: y & ytrnd
  function renderOutputLevelsChart(scenarios, ranges) {
    const traces = [];
    [...scenarios].reverse().forEach(s => {
      const seriesY = getSeries(s, "y", ranges.plotMin, ranges.plotMax);
      const seriesYtrnd = getSeries(s, "ytrnd", ranges.plotMin, ranges.plotMax);
      const yLn = seriesY.y.map(v =>
        typeof v === "number" && v > 0 ? Math.log(v) * 100 : null
      );
      const yTrndLn = seriesYtrnd.y.map(v =>
        typeof v === "number" && v > 0 ? Math.log(v) * 100 : null
      );

      traces.push({
        x: seriesY.x,
        y: yLn,
        customdata: seriesY.x,
        mode: "lines",
        name: s.name + " — Output",
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + " — Output: %{y:.2f}<extra></extra>"
      });

      traces.push({
        x: seriesYtrnd.x,
        y: yTrndLn,
        customdata: seriesYtrnd.x,
        mode: "lines",
        name: s.name + " — Potential",
        line: { color: s.color, dash: "dot" },
        hovertemplate: "%{customdata}<br>" + s.name + " — Potential: %{y:.2f}<extra></extra>"
      });
    });

    const layout = {
      title: "Output & Potential Output",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Level (ln × 100)" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-output-levels", traces, layout, { responsive: true });
  }

  // 3) Headline Inflation (%YoY): picpi4
  function renderHeadlineYoyChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "picpi4", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Headline Inflation (%YoY)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-headline-yoy", traces, layout, { responsive: true });
  }

  // 4) Core Inflation (%YoY): pi4
  function renderCoreYoyChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "pi4", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Core Inflation (%YoY)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-core-yoy", traces, layout, { responsive: true });
  }

  // 7) Ann. Potential Growth (%): dytrnd
  function renderPotentialGrowthChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "dytrnd", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Ann. Potential Growth (%)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-potential-growth", traces, layout, { responsive: true });
  }

  // 8) Core Inflation (%QoQ Ann.): pi
  function renderCoreQoqChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "pi", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Core Inflation (%QoQ Ann.)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-core-qoq", traces, layout, { responsive: true });
  }

  // 9) Headline Inflation (%QoQ Ann.): picpi
  function renderHeadlineQoqChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "picpi", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        customdata: series.x,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{customdata}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Headline Inflation (%QoQ Ann.)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: buildXAxisLayout(ranges),
      yaxis: { title: "Percent", tickformat: ".2f" },
      showlegend: false,
      shapes: buildActualDataShading(ranges)
    };
    Plotly.newPlot("chart-headline-qoq", traces, layout, { responsive: true });
  }


  function renderSummaryTables(scenarios, ranges) {
    const tableMin = ranges.tableMin;
    const tableMax = ranges.tableMax;
    renderSummaryLegend(scenarios);

    // Determine which variables are selected
    const varCheckboxes = document.querySelectorAll(".table-var-checkbox");
    const activeVarIds = Array.from(varCheckboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.getAttribute("data-var-id"))
      .filter(id => !!tableVarConfig[id]);

    if (!activeVarIds.length) {
      summaryTablesEl.innerHTML = "<p style='font-size:13px;color:var(--muted);'>Select at least one variable to display.</p>";
      return;
    }

    const vars = activeVarIds.map(id => ({
      id,
      label: tableVarConfig[id].label
    }));

    // Decide frequency: quarterly or yearly
    const isYearly = (summaryFrequency === "yearly");

    // Collect all periods within the table range across all scenarios
    const periodSet = new Set();
    scenarios.forEach(s => {
      (s.data || []).forEach(r => {
        const p = r.period;
        if (p != null && p !== "" && periodInRange(p, tableMin, tableMax)) {
          periodSet.add(String(p).trim());
        }
      });
    });

    let periods = Array.from(periodSet);
    periods.sort((a, b) => parsePeriodToIndex(a) - parsePeriodToIndex(b));

    if (!periods.length) {
      summaryTablesEl.innerHTML = "<p style='font-size:13px;color:var(--muted);'>No observations in the selected table range.</p>";
      return;
    }

    // Yearly aggregation helpers
    let yearlyPeriods = [];
    let yearlyLookups = {};
    if (isYearly) {
      // Build yearly period list: use the year extracted from any 4Q or any quarter in that year
      const yearSet = new Set();
      periods.forEach(p => {
        const parts = parsePeriodParts(p);
        if (parts) yearSet.add(parts.year);
      });
      const years = Array.from(yearSet).sort((a, b) => a - b);
      yearlyPeriods = years.map(y => String(y));

      // For each scenario, compute yearly aggregates
      scenarios.forEach(s => {
        const ymap = {};
        const byYear = {};

        (s.data || []).forEach(r => {
          const p = r.period;
          if (p == null || p === "") return;
          if (!periodInRange(p, tableMin, tableMax)) return;
          const parts = parsePeriodParts(p);
          if (!parts) return;
          const year = parts.year;
          if (!byYear[year]) byYear[year] = [];
          byYear[year].push(r);
        });

        Object.keys(byYear).forEach(yk => {
          const year = parseInt(yk, 10);
          const rows = byYear[year].sort((a, b) => parsePeriodToIndex(a.period) - parsePeriodToIndex(b.period));

          const candidateQ4 = rows.find(r => {
            const parts = parsePeriodParts(r.period);
            return parts && parts.q === 4;
          });
          const repRow = candidateQ4 || rows[rows.length - 1];

          const aggregated = Object.assign({}, repRow);

          if (Array.isArray(rows) && rows.length) {
            const last = rows[rows.length - 1];
            aggregated.ygap = (typeof last.avg_ygap === "number") ? last.avg_ygap : aggregated.ygap;
            aggregated.picpi4 = (typeof last.HL_inf === "number") ? last.HL_inf : aggregated.picpi4;
            aggregated.pi4 = (typeof last.CORE_inf === "number") ? last.CORE_inf : aggregated.pi4;
            aggregated.y_growth = (typeof last.dyA_nonsa === "number") ? last.dyA_nonsa : aggregated.y_growth;
            aggregated.annual_GDP = (typeof last.dyA_nonsa === "number") ? last.dyA_nonsa : aggregated.annual_GDP;
          }

          aggregated.period = String(year);
          ymap[aggregated.period] = aggregated;
        });

        yearlyLookups[s.name] = ymap;
      });
    }

    // For each scenario, build a lookup: period -> raw row (quarterly)
    const lookups = {};
    scenarios.forEach(s => {
      const map = {};
      (s.data || []).forEach(r => {
        const p = r.period;
        if (p == null || p === "") return;
        if (!periodInRange(p, tableMin, tableMax)) return;
        const key = String(p).trim();
        map[key] = r;
      });
      lookups[s.name] = map;
    });

    const scenariosOrdered = scenarios.map(s => s.name);
    const scenarioColorMap = {};
    scenarios.forEach(s => {
      scenarioColorMap[s.name] = s.color;
    });

    const displayPeriods = isYearly ? yearlyPeriods : periods;

    let html = `
      <table>
        <thead>
          <tr>
            <th rowspan="2">${isYearly ? "Year" : "Period"}</th>
    `;

    // First header row: variable names spanning all scenarios
    vars.forEach(v => {
      html += `<th colspan="${scenariosOrdered.length}">${v.label}</th>`;
    });

    html += `
          </tr>
          <tr>
    `;

    // Second header row: scenario names under each variable
    vars.forEach(() => {
      scenariosOrdered.forEach(name => {
        const color = colorCodeTableHeaders ? scenarioColorMap[name] : null;
        const colorStyle = color ? ` style="color:${color};"` : "";
        html += `<th${colorStyle}>${name}</th>`;
      });
    });

    html += `
          </tr>
        </thead>
        <tbody>
    `;

    // Body rows
    if (!isYearly) {
      // Quarterly: one row per period
      displayPeriods.forEach(p => {
        html += `<tr><td>${p}</td>`;
        vars.forEach(v => {
          const cfg = tableVarConfig[v.id];
          scenariosOrdered.forEach(name => {
            const lu = lookups[name] || {};
            const rec = lu[p];
            const color = colorCodeTableHeaders ? scenarioColorMap[name] : null;
            const styleAttr = color ? ` style="color:${color};"` : "";
            let val = "";
            if (rec && cfg && typeof cfg.accessor === "function") {
              const raw = cfg.accessor(rec);
              if (typeof raw === "number" && !isNaN(raw)) {
                val = raw.toFixed(2);
              }
            }
            html += `<td${styleAttr}>${val}</td>`;
          });
        });
        html += `</tr>`;
      });
    } else {
      // Yearly: one row per year
      displayPeriods.forEach(yearStr => {
        html += `<tr><td>${yearStr}</td>`;
        const year = parseInt(yearStr, 10);

        vars.forEach(v => {
          scenariosOrdered.forEach(name => {
            const color = colorCodeTableHeaders ? scenarioColorMap[name] : null;
            const styleAttr = color ? ` style="color:${color};"` : "";
            const cfg = tableVarConfig[v.id];

            const ymap = yearlyLookups[name] || {};
            const rec = ymap[yearStr];

            let val = "";
            if (rec && cfg && typeof cfg.accessor === "function") {
              const raw = cfg.accessor(rec);
              if (typeof raw === "number" && !isNaN(raw)) {
                val = raw.toFixed(2);
              }
            }
            html += `<td${styleAttr}>${val}</td>`;
          });
        });

        html += `</tr>`;
      });
    }

    html += "</tbody></table>";
    summaryTablesEl.innerHTML = html;
  }
</script>
<footer class="site-footer">
  © 2025 Nick
</footer>
</body>
</html>