<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MPC Policy Rate Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root {
      --bg: #f5f7fb;
      --fg: #0b1222;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --card: #ffffff;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    header {
      max-width: 1100px;
      margin: 24px auto 8px;
      padding: 0 16px;
    }
    h1 {
      margin: 0 0 4px;
      font-size: 26px;
      font-weight: 800;
    }
    .lede {
      margin: 0 0 16px;
      color: var(--muted);
      font-size: 14px;
    }
    main {
      max-width: 1100px;
      margin: 0 auto 32px;
      padding: 0 16px 32px;
    }
    .card {
      background: var(--card);
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 16px;
      box-shadow: 0 1px 2px rgba(15,23,42,0.04);
      margin-bottom: 16px;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }
    .scenario-row {
      display: grid;
      grid-template-columns: 2fr 1fr 2fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .scenario-row input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 13px;
    }
    .scenario-row input[type="file"] {
      font-size: 12px;
    }
    .scenario-row label {
      font-size: 12px;
      color: var(--muted);
    }
    .scenario-row button {
      border: none;
      background: transparent;
      color: #ef4444;
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 13px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-ghost {
      background: transparent;
      color: var(--fg);
      border-color: var(--border);
    }
    .btn + .btn {
      margin-left: 8px;
    }
    .step-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
    }
    #dashboard-step {
      display: none;
    }
    .charts-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 960px) {
      .charts-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    .chart-box {
      min-height: 280px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
    }
    th {
      background: #f9fafb;
      font-weight: 600;
      text-align: center;
    }
    td {
      text-align: center;
    }
    .table-option {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }
    .table-option input {
      margin: 0;
    }
    caption {
      caption-side: top;
      text-align: left;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--muted);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      background: #e0f2fe;
      color: #0369a1;
      font-size: 11px;
      font-weight: 500;
    }
    .range-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .range-input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 12px;
    }
    .range-sep {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .range-hint {
      font-size: 11px;
      color: var(--muted);
    }
    .site-footer {
      max-width: 1100px;
      margin: 0 auto 24px;
      padding: 8px 16px 0;
      font-size: 11px;
      color: var(--muted);
      text-align: right;
    }
  </style>
</head>
<body>

<header>
  <h1>MPC Policy Rate Projection Dashboard</h1>
  <p class="lede">
    Upload MPC projection CSVs (chartpackcsv), then compare output gaps and policy rate projections across scenarios.
  </p>
</header>

<main>
  <!-- Step 1: config and upload -->
  <section id="config-step" class="card">
    <h2>1. Upload projection files</h2>
    <div id="scenario-list"></div>
    <button id="add-scenario" class="btn btn-ghost">+ Add scenario</button>

    <div class="step-actions">
      <!-- Button moved to range-config; this area stays empty to keep spacing if needed -->
    </div>
  </section>

  <!-- Step 1.5: range configuration -->
  <section id="range-config" class="card">
    <h2>2. Set plot and table ranges</h2>
    <p style="font-size:13px;color:var(--muted);margin-bottom:10px;">
      Define the common time ranges used for all charts and tables. Leave fields blank to use defaults.
    </p>

    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;align-items:flex-start;max-width:100%;">
      <!-- Plot range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Plot range (all charts)
        </label>
        <div class="range-row">
          <select id="plot-min" class="range-input"></select>
          <span class="range-sep">to</span>
          <select id="plot-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–2030Q4</div>
      </div>

      <!-- Actual data range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Actual data range (shaded)
        </label>
        <div class="range-row">
          <select id="actual-min" class="range-input"></select>
          <span class="range-sep">to</span>
          <select id="actual-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–current quarter</div>
      </div>

      <!-- Table range -->
      <div>
        <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">
          Table range
        </label>
        <div class="range-row">
          <select id="table-min" class="range-input"></select>
          <span class="range-sep">to</span>
          <select id="table-max" class="range-input"></select>
        </div>
        <div class="range-hint">Default: 2019Q4–2030Q4</div>
      </div>
    </div>
    <div class="step-actions">
      <button id="build-dashboard" class="btn btn-primary">Build dashboard</button>
    </div>
  </section>

  <!-- Step 2: dashboard -->
  <section id="dashboard-step">
    <div class="card" style="margin-bottom:20px;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;">
        <h2 style="margin:0;">Interactive dashboard</h2>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="pill" id="scenario-count-label"></span>
          <button id="back-to-config" class="btn btn-ghost">Back to file selection</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="charts-grid">
        <div class="chart-box" id="chart-policy"></div>
        <div class="chart-box" id="chart-policy-step"></div>
        <div class="chart-box" id="chart-gdp"></div>
      </div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px;flex-wrap:wrap;">
        <h3 style="margin:0;font-size:14px;">Summary table</h3>
        <label class="table-option">
          <input type="checkbox" id="color-code-headers">
          <span>Color‑code scenarios</span>
        </label>
      </div>
      <div id="summary-tables"></div>
    </div>
  </section>
</main>

<script>
  // Global state
  const maxScenarios = 6;
  const scenarios = []; // {id, name, color, file, data}

  // Default ranges
  const defaultPlotMin = "2019Q4";
  const defaultPlotMax = "2030Q4";
  const defaultTableMin = "2019Q4";
  const defaultTableMax = "2030Q4";
  const defaultActualMin = "2019Q4";
  let availablePeriods = [];
  let currentScenarios = [];
  let colorCodeTableHeaders = false;

  function getCurrentQuarterLabel() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth(); // 0-based
    const q = Math.floor(month / 3) + 1;
    return year + "Q" + q;
  }
  const defaultActualMax = getCurrentQuarterLabel();

  const scenarioListEl   = document.getElementById("scenario-list");
  const addScenarioBtn   = document.getElementById("add-scenario");
  const buildDashboardBtn = document.getElementById("build-dashboard");
  const configStepEl     = document.getElementById("config-step");
  const dashboardStepEl  = document.getElementById("dashboard-step");
  const backToConfigBtn  = document.getElementById("back-to-config");
  const scenarioCountLbl = document.getElementById("scenario-count-label");
  const summaryTablesEl  = document.getElementById("summary-tables");
  const rangeConfigEl    = document.getElementById("range-config");
  const colorCodeHeadersCheckbox = document.getElementById("color-code-headers");
  if (colorCodeHeadersCheckbox) {
    colorCodeHeadersCheckbox.addEventListener("change", () => {
      colorCodeTableHeaders = !!colorCodeHeadersCheckbox.checked;
      reRenderIfReady();
    });
  }

  const plotMinInput   = document.getElementById("plot-min");
  const plotMaxInput   = document.getElementById("plot-max");
  const actualMinInput = document.getElementById("actual-min");
  const actualMaxInput = document.getElementById("actual-max");
  const tableMinInput  = document.getElementById("table-min");
  const tableMaxInput  = document.getElementById("table-max");


  function getRangeConfig() {
    return {
      plotMin: (plotMinInput && plotMinInput.value) || defaultPlotMin,
      plotMax: (plotMaxInput && plotMaxInput.value) || defaultPlotMax,
      actualMin: (actualMinInput && actualMinInput.value) || defaultActualMin,
      actualMax: (actualMaxInput && actualMaxInput.value) || defaultActualMax,
      tableMin: (tableMinInput && tableMinInput.value) || defaultTableMin,
      tableMax: (tableMaxInput && tableMaxInput.value) || defaultTableMax
    };
  }

  function getAllPeriodsFromScenarios(scens) {
    const set = new Set();
    scens.forEach(s => {
      (s.data || []).forEach(r => {
        if (r.period != null && r.period !== "") {
          const p = String(r.period).trim();
          if (parsePeriodToIndex(p) != null) {
            set.add(p);
          }
        }
      });
    });
    const arr = Array.from(set);
    arr.sort((a, b) => parsePeriodToIndex(a) - parsePeriodToIndex(b));
    return arr;
  }

  function populateSelectFromPeriods(selectEl, defaultVal, isMax) {
    if (!selectEl || !availablePeriods.length) return;
    selectEl.innerHTML = "";
    availablePeriods.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      selectEl.appendChild(opt);
    });

    const first = availablePeriods[0];
    const last = availablePeriods[availablePeriods.length - 1];
    const firstIdx = parsePeriodToIndex(first);
    const lastIdx = parsePeriodToIndex(last);

    let chosen = defaultVal;
    const chosenIdx = chosen && parsePeriodToIndex(chosen);

    if (!chosenIdx) {
      chosen = isMax ? last : first;
    } else {
      if (chosenIdx < firstIdx) chosen = first;
      if (chosenIdx > lastIdx) chosen = last;
    }

    selectEl.value = chosen;
  }

  function populateRangeSelects() {
    if (!availablePeriods.length) return;
    populateSelectFromPeriods(plotMinInput, defaultPlotMin, false);
    populateSelectFromPeriods(plotMaxInput, defaultPlotMax, true);
    populateSelectFromPeriods(actualMinInput, defaultActualMin, false);
    populateSelectFromPeriods(actualMaxInput, defaultActualMax, true);
    populateSelectFromPeriods(tableMinInput, defaultTableMin, false);
    populateSelectFromPeriods(tableMaxInput, defaultTableMax, true);
  }

  function refreshAvailablePeriodsAndSelects() {
    const scensWithData = scenarios.filter(s => Array.isArray(s.data) && s.data.length > 0);
    if (!scensWithData.length) {
      availablePeriods = [];
      return;
    }
    availablePeriods = getAllPeriodsFromScenarios(scensWithData);
    populateRangeSelects();
  }

  // Helpers
  function createScenarioRow(id, scenario) {
    const row = document.createElement("div");
    row.className = "scenario-row";
    row.dataset.id = id;

    row.innerHTML = `
      <div>
        <label>Scenario name</label>
        <input type="text" placeholder="e.g. MPC Dec-25 (Day 1)" class="scenario-name">
      </div>
      <div>
        <label>Line color</label>
        <input type="color" class="scenario-color" value="${scenario.color}">
      </div>
      <div>
        <label>CSV file</label>
        <input type="file" accept=".csv" class="scenario-file">
      </div>
      <button type="button" class="remove-scenario" title="Remove scenario">&times;</button>
    `;

    // Wire remove
    row.querySelector(".remove-scenario").addEventListener("click", () => {
      const idx = scenarios.findIndex(s => s.id === id);
      if (idx >= 0) scenarios.splice(idx, 1);
      row.remove();
      refreshAvailablePeriodsAndSelects();
    });

    // Wire inputs to state
    row.querySelector(".scenario-name").addEventListener("input", e => {
      const s = scenarios.find(s => s.id === id);
      if (s) s.name = e.target.value;
    });
    row.querySelector(".scenario-color").addEventListener("input", e => {
      const s = scenarios.find(s => s.id === id);
      if (s) s.color = e.target.value;
    });
    row.querySelector(".scenario-file").addEventListener("change", e => {
      const s = scenarios.find(s => s.id === id);
      const file = e.target.files[0] || null;
      if (s) s.file = file;

      if (file) {
        // Extract name
        let fname = file.name.replace(/\.[^/.]+$/, ""); // remove extension

        // Convert "chartpackcsv_Dec25_Internal Briefing" into "MPC Dec-25 (Internal Briefing)"
        // Step 1: extract month+year (e.g. Dec25)
        const match = fname.match(/_(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{2})/i);
        let scenarioLabel = "";

        if (match) {
          const m = match[1];
          const y = match[2];
          scenarioLabel = `MPC ${m}-${y}`;
        } else {
          scenarioLabel = "MPC Scenario";
        }

        // Step 2: extract descriptor after month-year
        const parts = fname.split(match ? match[0] : "");
        if (parts.length > 1) {
          let desc = parts[1].replace(/[_-]+/g, " ").trim();
          if (desc) scenarioLabel += ` (${desc})`;
        }

        // Update scenario state + input field
        s.name = scenarioLabel;
        row.querySelector(".scenario-name").value = scenarioLabel;

        // Parse this file immediately to populate data and refresh ranges
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: results => {
            const rows = results.data.filter(r => r.period != null && r.period !== "");
            s.data = rows;
            refreshAvailablePeriodsAndSelects();
          },
          error: err => {
            console.error(err);
            alert("There was a problem reading " + file.name + ". Please check the format.");
          }
        });
      }
    });

    return row;
  }

  function addScenario() {
    if (scenarios.length >= maxScenarios) {
      alert(`You can upload at most ${maxScenarios} scenarios for now.`);
      return;
    }
    const id = Date.now() + "_" + Math.random().toString(16).slice(2);
    const defaultColors = ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b"];
    const scenario = {
      id,
      name: "",
      color: defaultColors[scenarios.length] || "#000000",
      file: null,
      data: null
    };
    scenarios.push(scenario);
    const row = createScenarioRow(id, scenario);
    scenarioListEl.appendChild(row);
  }

  // Initialize with 2 rows by default
  addScenario();
  addScenario();

  addScenarioBtn.addEventListener("click", addScenario);

  // Parse one scenario CSV into scenario.data
  function parseScenario(scenario) {
    return new Promise((resolve, reject) => {
      if (!scenario.file) {
        return reject(new Error("Missing file for scenario " + (scenario.name || "")));
      }
      Papa.parse(scenario.file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: results => {
          const rows = results.data.filter(r => r.period != null && r.period !== "");
          scenario.data = rows;
          resolve(scenario);
        },
        error: err => reject(err)
      });
    });
  }

  function validateScenarios() {
    const valid = scenarios.filter(s => s.file);
    if (valid.length === 0) {
      alert("Please upload at least one CSV file.");
      return null;
    }
    // Fill default names
    valid.forEach((s, idx) => {
      if (!s.name || !s.name.trim()) {
        s.name = "Scenario " + (idx + 1);
      }
    });
    return valid;
  }

  // Main build dashboard action
  buildDashboardBtn.addEventListener("click", () => {
    const validScenarios = scenarios.filter(s => Array.isArray(s.data) && s.data.length > 0);
    if (!validScenarios.length) {
      alert("Please upload at least one valid CSV file before building the dashboard.");
      return;
    }

    // Ensure ranges are populated if not done yet
    if (!availablePeriods.length) {
      availablePeriods = getAllPeriodsFromScenarios(validScenarios);
      populateRangeSelects();
    }

    currentScenarios = validScenarios;

    // Hide upload and range cards, show dashboard
    configStepEl.style.display = "none";
    rangeConfigEl.style.display = "none";
    dashboardStepEl.style.display = "block";
    scenarioCountLbl.textContent = `${validScenarios.length} scenario${validScenarios.length > 1 ? "s" : ""} loaded`;
    renderDashboard(currentScenarios);
  });

  backToConfigBtn.addEventListener("click", () => {
    dashboardStepEl.style.display = "none";
    configStepEl.style.display = "block";
    rangeConfigEl.style.display = "block";
  });
  function reRenderIfReady() {
    if (dashboardStepEl.style.display !== "none" && currentScenarios && currentScenarios.length) {
      renderDashboard(currentScenarios);
    }
  }

  [plotMinInput, plotMaxInput, actualMinInput, actualMaxInput, tableMinInput, tableMaxInput].forEach(el => {
    if (!el) return;
    el.addEventListener("change", reRenderIfReady);
  });

  // Helpers for period range
  function parsePeriodToIndex(p) {
    if (p == null) return null;
    const m = /^(\d{4})Q([1-4])$/.exec(String(p).trim());
    if (!m) return null;
    const year = parseInt(m[1], 10);
    const q = parseInt(m[2], 10);
    if (!year || !q) return null;
    return year * 4 + q;
  }

  function periodInRange(p, minP, maxP) {
    const idx = parsePeriodToIndex(p);
    if (idx == null) return true; // if we cannot parse, do not filter out
    const minIdx = minP ? parsePeriodToIndex(minP) : null;
    const maxIdx = maxP ? parsePeriodToIndex(maxP) : null;
    if (minIdx != null && idx < minIdx) return false;
    if (maxIdx != null && idx > maxIdx) return false;
    return true;
  }

  function getSeries(scenario, colName, minPeriod, maxPeriod) {
    const rows = scenario.data || [];
    const x = [];
    const y = [];
    for (const r of rows) {
      const xv = r.period;
      const yv = r[colName];
      if (
        xv != null &&
        xv !== "" &&
        typeof yv === "number" &&
        !isNaN(yv) &&
        periodInRange(xv, minPeriod, maxPeriod)
      ) {
        x.push(xv);
        y.push(yv);
      }
    }
    return { x, y };
  }

  // Render plots and tables
  function renderDashboard(scenarios) {
    const ranges = getRangeConfig();
    renderPolicyChart(scenarios, ranges);
    renderPolicyStepChart(scenarios, ranges);
    renderGdpChart(scenarios, ranges);
    renderSummaryTables(scenarios, ranges);
  }

  function renderPolicyChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, "i", ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{x}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Policy Rate (i)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: { title: "Period" },
      yaxis: { title: "Percent", tickformat: ".2f" },
      legend: { orientation: "h", y: -0.2 },
      shapes: [
        {
          type: "rect",
          xref: "x",
          yref: "paper",
          x0: ranges.actualMin,
          x1: ranges.actualMax,
          y0: 0,
          y1: 1,
          fillcolor: "rgba(15,23,42,0.08)",
          line: { width: 0 }
        }
      ]
    };
    Plotly.newPlot("chart-policy", traces, layout, { responsive: true });
  }

  function renderPolicyStepChart(scenarios, ranges) {
    const traces = [...scenarios].reverse().map(s => {
      const raw = getSeries(s, "i", ranges.plotMin, ranges.plotMax);
      const steppedY = raw.y.map(v => {
        if (typeof v === "number" && !isNaN(v)) {
          return Math.round(v / 0.25) * 0.25;
        }
        return null;
      });
      return {
        x: raw.x,
        y: steppedY,
        mode: "lines",
        name: s.name,
        line: { color: s.color, dash: "dot" },
        hovertemplate: "%{x}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Policy Rate (step, 0.25 increments)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: { title: "Period" },
      yaxis: { title: "Percent", tickformat: ".2f" },
      legend: { orientation: "h", y: -0.2 },
      shapes: [
        {
          type: "rect",
          xref: "x",
          yref: "paper",
          x0: ranges.actualMin,
          x1: ranges.actualMax,
          y0: 0,
          y1: 1,
          fillcolor: "rgba(15,23,42,0.08)",
          line: { width: 0 }
        }
      ]
    };
    Plotly.newPlot("chart-policy-step", traces, layout, { responsive: true });
  }

  function renderGdpChart(scenarios, ranges) {
    // Using dy4_r as GDP yoy. Change here if you want a different column.
    const gdpCol = "dy4_r";
    const traces = [...scenarios].reverse().map(s => {
      const series = getSeries(s, gdpCol, ranges.plotMin, ranges.plotMax);
      return {
        x: series.x,
        y: series.y,
        mode: "lines",
        name: s.name,
        line: { color: s.color },
        hovertemplate: "%{x}<br>" + s.name + ": %{y:.2f}%<extra></extra>"
      };
    });
    const layout = {
      title: "Real GDP Growth (dy4_r, yoy)",
      margin: { t: 40, r: 10, b: 40, l: 55 },
      xaxis: { title: "Period" },
      yaxis: { title: "Percent", tickformat: ".1f" },
      legend: { orientation: "h", y: -0.2 },
      shapes: [
        {
          type: "rect",
          xref: "x",
          yref: "paper",
          x0: ranges.actualMin,
          x1: ranges.actualMax,
          y0: 0,
          y1: 1,
          fillcolor: "rgba(15,23,42,0.08)",
          line: { width: 0 }
        }
      ]
    };
    Plotly.newPlot("chart-gdp", traces, layout, { responsive: true });
  }

  function renderSummaryTables(scenarios, ranges) {
    // Build a time-series table over the table range:
    // rows = periods, columns = variables × scenarios
    const tableMin = ranges.tableMin;
    const tableMax = ranges.tableMax;

    // Collect all periods within the table range across all scenarios
    const periodSet = new Set();
    scenarios.forEach(s => {
      (s.data || []).forEach(r => {
        const p = r.period;
        if (p != null && p !== "" && periodInRange(p, tableMin, tableMax)) {
          periodSet.add(String(p).trim());
        }
      });
    });

    const periods = Array.from(periodSet);
    periods.sort((a, b) => parsePeriodToIndex(a) - parsePeriodToIndex(b));

    if (!periods.length) {
      summaryTablesEl.innerHTML = "<p style='font-size:13px;color:var(--muted);'>No observations in the selected table range.</p>";
      return;
    }

    // For each scenario, build a lookup: period -> {policy, policyStep, gdp}
    const lookups = {};
    scenarios.forEach(s => {
      const map = {};
      (s.data || []).forEach(r => {
        const p = r.period;
        if (p == null || p === "") return;
        if (!periodInRange(p, tableMin, tableMax)) return;
        const key = String(p).trim();
        const policy = Number(r.i);
        const policyStep = typeof policy === "number" && !isNaN(policy)
          ? Math.round(policy / 0.25) * 0.25
          : NaN;
        const gdp = Number(r.dy4_r);
        map[key] = {
          policy,
          policyStep,
          gdp
        };
      });
      lookups[s.name] = map;
    });

    const scenariosOrdered = scenarios.map(s => s.name);
    const scenarioColorMap = {};
    scenarios.forEach(s => {
    scenarioColorMap[s.name] = s.color;
    });

    // Variables to display as top-level columns
    const vars = [
      { key: "policy", label: "Policy rate (i)" },
      { key: "policyStep", label: "Policy rate (step)" },
      { key: "gdp", label: "Real GDP yoy (dy4_r)" }
    ];

    let html = `
      <table>
        
        <thead>
          <tr>
            <th rowspan="2">Period</th>
    `;

    // First header row: variable names spanning all scenarios
    vars.forEach(v => {
      html += `<th colspan="${scenariosOrdered.length}">${v.label}</th>`;
    });

    html += `
          </tr>
          <tr>
    `;

    // Second header row: scenario names under each variable
    vars.forEach(() => {
    scenariosOrdered.forEach(name => {
        const color = colorCodeTableHeaders ? scenarioColorMap[name] : null;
        const colorStyle = color ? ` style="color:${color};"` : "";
        html += `<th${colorStyle}>${name}</th>`;
    });
    });

    html += `
          </tr>
        </thead>
        <tbody>
    `;

    // Body rows: one per period
    periods.forEach(p => {
    html += `<tr><td>${p}</td>`;
    vars.forEach(v => {
        scenariosOrdered.forEach(name => {
        const lu = lookups[name] || {};
        const rec = lu[p];
        let val = "";
        if (rec && typeof rec[v.key] === "number" && !isNaN(rec[v.key])) {
            val = rec[v.key].toFixed(2);
        }
        const color = colorCodeTableHeaders ? scenarioColorMap[name] : null;
        const styleAttr = color ? ` style="color:${color};"` : "";
        html += `<td${styleAttr}>${val}</td>`;
        });
    });
    html += `</tr>`;
    });

    html += "</tbody></table>";

    summaryTablesEl.innerHTML = html;
  }
</script>
<footer class="site-footer">
  © 2025 Nick
</footer>
</body>
</html>